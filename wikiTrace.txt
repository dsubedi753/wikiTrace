// manifest.json
{
  "manifest_version": 3,
  "name": "Wikipedia Navigation Visualizer",
  "version": "1.0",
  "description": "Tracks and visualizes your Wikipedia browsing history as a tree",
  "permissions": ["storage", "tabs"],
  "host_permissions": ["*://*.wikipedia.org/*"],
  "action": {
    "default_popup": "popup.html"
  },
  "content_scripts": [{
    "matches": ["*://*.wikipedia.org/*"],
    "js": ["content.js"]
  }],
  "background": {
    "service_worker": "background.js"
  }
}

// popup.html
<!DOCTYPE html>
<html>
<head>
  <title>Wikipedia Navigation Tree</title>
  <link rel="stylesheet" href="styles.css">
  <script src="d3.v7.min.js"></script>
</head>
<body>
  <div class="controls">
    <button id="refreshGraph">Refresh</button>
    <button id="clearHistory">Clear History</button>
  </div>
  <div id="graph">
    <svg width="100%" height="100%"></svg>
  </div>
  <script src="popup.js"></script>
</body>
</html>

// styles.css
body {
  width: 800px;
  height: 600px;
  padding: 20px;
  margin: 0;
  background: #000000;
  font-family: system-ui, -apple-system, sans-serif;
  color: white;
}

#graph {
  width: 100%;
  height: 500px;
  border: 1px solid #333;
  border-radius: 4px;
  overflow: hidden;
  background: #000000;
}

.controls {
  margin: 10px 0;
  display: flex;
  gap: 10px;
}

button {
  padding: 8px 16px;
  background: #1a1a1a;
  color: #ffffff;
  border: 1px solid #333;
  border-radius: 4px;
  cursor: pointer;
}

button:hover {
  background: #2a2a2a;
}

.node-box {
  fill: #1a1a1a;
  stroke: #4488ff;
  stroke-width: 2;
}

.node-label {
  fill: white;
  font-size: 12px;
  font-weight: 500;
}

.link {
  stroke: #4488ff;
  stroke-width: 1.5;
  fill: none;
}

// background.js
chrome.runtime.onInstalled.addListener(function() {
  console.log('Wikipedia Navigation Tree installed');
  // Initialize empty tree
  chrome.storage.local.set({ wikiTree: {} });
});

// content.js
class WikiNode {
    constructor(title) {
        this.title = title;
        this.children = new Set();  // Using Set to avoid duplicate children
        this.timestamp = new Date().toISOString();
    }

    addChild(childNode) {
        this.children.add(childNode);
    }

    toJSON() {
        return {
            title: this.title,
            children: Array.from(this.children).map(child => child.title),
            timestamp: this.timestamp
        };
    }
}

class WikiTree {
    constructor() {
        this.nodes = new Map();  // title -> WikiNode
    }

    getOrCreateNode(title) {
        if (!this.nodes.has(title)) {
            this.nodes.set(title, new WikiNode(title));
        }
        return this.nodes.get(title);
    }

    addConnection(fromTitle, toTitle) {
        const parentNode = this.getOrCreateNode(fromTitle);
        const childNode = this.getOrCreateNode(toTitle);
        parentNode.addChild(childNode);
        
        console.log('Added connection:', fromTitle, '->', toTitle);
        this.saveToStorage();
    }

    toJSON() {
        const nodes = {};
        this.nodes.forEach((node, title) => {
            nodes[title] = node.toJSON();
        });
        return nodes;
    }

    saveToStorage() {
        const data = this.toJSON();
        console.log('Saving tree:', data);
        chrome.storage.local.set({ wikiTree: data });
    }

    static async fromStorage() {
        return new Promise((resolve) => {
            chrome.storage.local.get(['wikiTree'], (result) => {
                const tree = new WikiTree();
                if (result.wikiTree) {
                    Object.entries(result.wikiTree).forEach(([title, data]) => {
                        const node = tree.getOrCreateNode(title);
                        data.children.forEach(childTitle => {
                            const childNode = tree.getOrCreateNode(childTitle);
                            node.addChild(childNode);
                        });
                    });
                }
                resolve(tree);
            });
        });
    }
}

// Global tree instance
let wikiTree;

// Initialize tree from storage
WikiTree.fromStorage().then(tree => {
    wikiTree = tree;
    console.log('Wiki tree initialized:', tree);
});

// Track current page
let currentTitle = null;

function getWikipediaTitle() {
    const titleElement = document.getElementById('firstHeading');
    return titleElement ? titleElement.textContent.trim() : null;
}

// Track clicks on Wikipedia links
document.addEventListener('click', function(e) {
    const link = e.target.closest('a[href*="/wiki/"]');
    if (!link) return;

    const fromTitle = getWikipediaTitle();
    if (fromTitle) {
        console.log('Storing source page:', fromTitle);
        chrome.storage.local.set({ lastSourcePage: fromTitle });
    }
});

// When page loads, check if we came from another Wikipedia page
window.addEventListener('load', function() {
    currentTitle = getWikipediaTitle();
    if (!currentTitle) return;

    console.log('Page loaded:', currentTitle);
    chrome.storage.local.get(['lastSourcePage'], function(result) {
        if (result.lastSourcePage) {
            console.log('Found source page:', result.lastSourcePage);
            wikiTree.addConnection(result.lastSourcePage, currentTitle);
            chrome.storage.local.remove('lastSourcePage');
        }
    });
});

// popup.js
class WikiGraphVisualizer {
    constructor(svgElement) {
        this.svg = d3.select(svgElement);
        this.width = svgElement.clientWidth;
        this.height = svgElement.clientHeight;
        
        this.treeLayout = d3.tree()
            .size([this.height - 100, this.width - 200]);
            
        this.container = this.svg.append('g')
            .attr('transform', 'translate(100,50)');
            
        this.setupZoom();
    }

    setupZoom() {
        const zoom = d3.zoom()
            .scaleExtent([0.1, 3])
            .on('zoom', (event) => {
                this.container.attr('transform', event.transform);
            });

        this.svg.call(zoom);
    }

    processData(wikiTree) {
        if (!wikiTree || Object.keys(wikiTree).length === 0) return null;

        // Find root (node with no parents)
        const childTitles = new Set();
        Object.values(wikiTree).forEach(node => {
            node.children.forEach(child => childTitles.add(child));
        });
        
        const rootTitle = Object.keys(wikiTree).find(title => !childTitles.has(title));
        if (!rootTitle) return null;
        
        function buildHierarchy(title) {
            const node = wikiTree[title];
            if (!node) return null;
            
            return {
                name: title,
                children: node.children
                    .map(buildHierarchy)
                    .filter(child => child !== null)
            };
        }

        return buildHierarchy(rootTitle);
    }

    render(wikiTree) {
        console.log('Rendering tree:', wikiTree);
        this.container.selectAll('*').remove();

        const hierarchyData = this.processData(wikiTree);
        if (!hierarchyData) {
            this.showEmptyMessage();
            return;
        }

        const root = d3.hierarchy(hierarchyData);
        this.treeLayout(root);

        // Draw links
        this.container.append('g')
            .attr('class', 'links')
            .selectAll('path')
            .data(root.links())
            .join('path')
            .attr('class', 'link')
            .attr('d', d3.linkHorizontal()
                .x(d => d.y)
                .y(d => d.x));

        // Draw nodes
        const nodes = this.container.append('g')
            .attr('class', 'nodes')
            .selectAll('g')
            .data(root.descendants())
            .join('g')
            .attr('transform', d => `translate(${d.y},${d.x})`);

        nodes.append('rect')
            .attr('class', 'node-box')
            .attr('x', -75)
            .attr('y', -20)
            .attr('width', 150)
            .attr('height', 40)
            .attr('rx', 5);

        nodes.append('text')
            .attr('class', 'node-label')
            .attr('dy', '0.32em')
            .attr('text-anchor', 'middle')
            .text(d => d.data.name.length > 20 ? 
                d.data.name.substring(0, 20) + '...' : 
                d.data.name);
    }

    showEmptyMessage() {
        this.container.append('text')
            .attr('x', this.width / 2)
            .attr('y', this.height / 2)
            .attr('text-anchor', 'middle')
            .attr('fill', 'white')
            .text('No navigation history yet. Start browsing Wikipedia!');
    }
}

document.addEventListener('DOMContentLoaded', function() {
    console.log('Popup opened');
    const svg = document.querySelector('#graph svg');
    const visualizer = new WikiGraphVisualizer(svg);
    
    function updateGraph() {
        chrome.storage.local.get(['wikiTree'], function(result) {
            console.log('Retrieved tree data:', result.wikiTree);
            visualizer.render(result.wikiTree || {});
        });
    }
    
    document.getElementById('refreshGraph').addEventListener('click', updateGraph);
    
    document.getElementById('clearHistory').addEventListener('click', function() {
        chrome.storage.local.set({ wikiTree: {} }, function() {
            console.log('History cleared');
            updateGraph();
        });
    });
    
    updateGraph();
});